.TH bert.js 1 "bert.js" "Synrc Research Center" "BERT.JS"
.SH NAME
bert.js

.SH ВСТУП
.LP
Модуль
\fIbert.js\fR\& надає JavaScript кодер/декодер для
\fIExternal Term Format\fR\& ,
який використовується в Erlang distribution protocol.
Це означає, що ваші JavaScript програми надсилають повідомлення
в рідному форматі Erlang. Цей модуль застосовує
\fIDataView\fR\& ,
а також методи
getUint8
,
getUint16
,
getUint32
, які забезпечують
найшвидший варіант роботи з бінарними даними в JavaScript.
Ця бібліотека використовується в Erlang і Haskell версіях N2O.
Розмір
bert.js
— 4654 байта.
.LP
Зауважте, що це низькорівнева бібліотека, швидка версія
BERT кодера/декодера. Якщо ви хочете генерувати
JavaScript SDK з іменованими полями, як в файлах заголовків Erlang,
підключіть
\fIBERT\fR\& —
високорівневу бібліотеку-двійника, яка генерує
обгортки навколо
bert.js
та забезпечує
більш more slick JavaScript досвід.
.LP
Erlang структура, яка компілюється в BERT формат:
.nf
#io{ code = login,
data = { 'Token', 42 } }
.fi
.LP
Цільова структура
\fIbert.js\fR\& — швидкий низькорівневий жорстко закодований парсер з BERT формату.
.LP
.nf
{ t: 104,
v: [ { t: 100, v: "io" },
{ t: 100, v: "login" },
{ t: 104, v: [ { t: 100, v: "Token" },
{ t: 97,  v: 42 } ] } ] }
.fi
.LP
Цільова структура згенерованого парсера з
\fIBERT\fR\& parse transform:
.LP
.nf
{ tup: 'io',
code: 'login',
data: { tup: '$',
0: 'Token',
1: 42 } },
.fi
.LP
Підтримується наступна практична підмножина формату BERT:

.SH 70
.LP
Кодування числа з плаваючою точкою IEEE-754; зберігається у вигляді 8 байтів у big-endian IEEE форматі.
Цей вираз використовується в мінорній версії 1 зовнішнього формату.
.nf
1    8
70   IEEE-754 float
.fi

.SH 97
.LP
Кодування байтів. Беззнакове 8-бітне ціле число (integer).
.nf
1    1
97   Int
.fi

.SH 98
.LP
Кодування цілих чисел (Integer). 32-бітне ціле число зі знаком, в big-endian форматі.
.nf
1    4
98   Int
.fi

.SH 99
.LP
Кодування числа з плаваючою точкою POSIX; зберігається у вигляді строки. Формат використовується в
sprintf, для форматування чисел з плаваючою точкою, як "%.20e" (виділяється більше байтів, ніж необхідно).
Для розпакування числа з плаваючою точкою використовується sscanf з форматом "%lf".
.nf
1    31
99   Float POSIX string.
.fi

.SH 100
.LP
Кодування атомів. Атом зберігається у вигляді 2-байтового беззнакового цілого числа в big-endian порядку,
яким задається довжина, за ним слідують N чисел — 8-бітних Latin-1 знаків (Characters), які є ім'ям атома.
Максимально дозволене значення довжини є 255.
.nf
1    2    N
100  N    Characters
.fi

.SH 104
.LP
Кодування кортежу. Поле арності (Arity) — беззнакове 1-байте ціле число N, яке визначає,
скільки елементів знаходиться в секції Елементи (Elements).
.nf
1    1    N
104  N    Elements
.fi

.SH 105
.LP
Кодування великого кортежу. Відмінність від 104 — N є беззнаковим
4-байтним цілим числом в big-endian форматі.
.nf
1    4    N
105  N    Elements
.fi

.SH 106
.LP
Nil.
.nf
1
106
.fi

.SH 107
.LP
Кодування строки. Оскільки поле N є беззнаковим 2-байтним
числом (big-endian), реалізації повинні гарантувати, що списки,
довші за 65535 елементів, кодуються за допомогою 108.
.nf
1    2    N
107  N    Characters
.fi

.SH 108
.LP
Кодування списків. N — кількість елементів в секції Символи (Characters).
Хвіст (Tail) — остаточний хвіст списку; це 106 для правильного списку,
але, у випадку неправильного списку, може бути будь-якого типу (наприклад, [a|b]).
.nf
1    4    N
108  N    Characters  Tail
.fi

.SH 109
.LP
Бінарне кодування. Бінарні строки генеруються за допомогою бітового синтаксичного виразу (bit syntax expression) або
erlang:list_to_binary/1, erlang:term_to_binary/1, чи як
вхідні дані від бінарних портів (binary ports). Поле довжини N є
беззнаковим 4-байтним цілим числом (big-endian).
.nf
1    4    N
109  N    Bytes
.fi

.SH 110
.LP
Кодування малого bignum. Bignum зберігається в унарній формі з байтом знаку,
який дорівнює 0, якщо binum позитивний, і 1, якщо негативний.
При зберіганні цифр молодший байт зберігаються першим.
Для обчислення цілого числа можна використовувати наступну формулу:
.nf
1    1    1    n
110  n    Sign d(0)...d(n-1)
.fi
.LP
B = 256,
d
0
*B
0
+ d
1
*B
1
+ d
2
*B
2
+ ... d
N-1
*B
(n-1)

.SH 111
.LP
Кодування великого bignum.
Відмінність від 110 — поле довжини є беззнаковим 4-байтним цілим числом.
.nf
1    4    1    n
111  n    Sign d(0)...d(n-1)
.fi

.SH 115
.LP
Кодування малого атома. Атом зберігається у вигляді 1-байтового беззнакового цілого числа в big-endian порядку,
яким задається довжина, за ним слідують N чисел — 8-бітних Latin-1 знаків (Characters), які є ім'ям атома.
Максимально дозволене значення довжини є 16.
.nf
1    1    N
115  N    Characters
.fi

.SH 116
.LP
Кодування мапи (map). Поле N — беззнакове 4-байтне ціле число
в big-endian форматі, означає кількість пар "ключ-значення"
в map. Пари "ключ-значення" (Ki => Vi) кодуються
у секції Пари (Pairs) в наступному порядку: K1, V1, K2, V2,..., Kn, Vn.
Дублікати ключів не дозволені в одній і тій же map.
Вимагає OTP 17.
.nf
1    4    N
116  N    K1,V1,K2,V2,...
.fi

.SH 118
.LP
Кодування UTF8 атома. Атом зберігається у вигляді 2-байтового беззнакового цілого числа в big-endian порядку,
яким задається довжина, за ним слідують N байтів — закодовані в UTF-8 символи (Characters), які є ім'ям атома.
.nf
1    2    N
118  N    Characters
.fi

.SH 119
.LP
Кодування малого UTF8 атома. Атом зберігається у вигляді 1-байтового беззнакового цілого числа,
яким задається довжина, за ним слідують N байтів — закодовані в UTF-8 символи (Characters), які є ім'ям атома.
Довші атоми, закодовані в UTF-8, можна представити за допомогою 118.
.nf
1    1    N
119  N    Characters
.fi

.SH API
enc(json)
.LP
Кодує внутрішній JSON в двійковий буфер.
.nf
> enc({t: 119, v: "日本"})
Uint8Array([131,119,6,230,151,165,230,156,172])
.fi
dec(buffer)
.LP
Декодує двійковий буфер у внутрішній JSON.
.nf
> dec((new Uint8Array([131,119,6,230,151,165,230,156,172])).buffer)
{t: 119, v: "日本"}
.fi
bin(x)
.nf
> dec(enc(bin('N2O,')).buffer))
{t: 109, v: "N2O,"}
[131,109,0,0,0,4,78,50,79,44]
.fi
.LP
Створює JSON для двійкового кодування.
atom(x)
.LP
Створює JSON для кодування Latin-1 атома.
.nf
> dec(enc(atom('ok')).buffer))
{t: 100, v: "ok"}
[131,100,0,2,111,107]
.fi
string(x)
.LP
Створює JSON для кодування строки.
.nf
> dec(enc(string('ok')).buffer))
{t: 107, v: "ok"}
[131,107,0,2,111,107]
.fi
float(x)
.LP
Створює JSON для кодування числа з плаваючою точкою IEEE-754.
.nf
> dec(enc(float('123.13')).buffer)
{t: 70, v: 123.13}
[131,70,64,94,200,81,235,133,30,184]
.fi
number(x)
.LP
Створює JSON для кодування цілих чисел та великих чисел GMP.
.nf
> dec(enc(number('1')).buffer)
{t: 97, v: 1}
[131,97,1]
> dec(enc(number('100000000')).buffer)
{t: 98, v: 100000000}
[131,98,5,245,225,0]
> dec(enc(number('10000000000000000000000')).buffer)
{t: 110, v: 1e+22}
[131,110,10,0,0,0,64,178,186,201,224,25,30,2]
.fi
list(x,...)
.LP
Створює JSON для кодування списку.
.nf
> dec(enc(list(atom('1'),number('1'),bin('1'))).buffer)
{t: 108, v: [{t: 100, v: "1"},
{t: 97, v: 1},
{t: 109, v: "1"}]}
[131,108,0,0,0,3,100,0,1,49,97,1,109,0,0,0,1,49,106]
.fi
tuple(x,...)
.LP
Створює JSON для кодування кортежу.
.nf
> dec(enc(tuple(atom('1'),number('1'),bin('1'))).buffer)
{t: 104, v: [{t: 100, v: "1"},
{t: 97, v: 1},
{t: 109, v: "1"}]}
[131,104,3,100,0,1,49,97,1,109,0,0,0,1,49]
.fi
map(x,...)
.LP
Створює JSON для кодування мапи.
.nf
> dec(enc(map(
{k:bin('rent'),v:float(1.2)},
{k:atom('ok'),  v:list(number(1),float(1.0),bin('1'))})).buffer)
{t:116, v:[{k:{t:109,v:"rent"},v:{t:70, v:1.2}},
{k:{t:100,v:"ok"},  v:{t:108,v:[{t:97, v:1},
{t:70, v:1},
{t:109,v:"1"}]}}]}
[131,116,0,0,0,2,109,0,0,0,4,114,101,110,
116,70,63,243,51,51,51,51,51,51,100,0,2,
111,107,108,0,0,0,3,97,1,70,63,240,0,0,0,
0,0,0,109,0,0,0,1,49,106]
.fi

.SH ALSO
.LP
\fB\fIutf8.js(1)\fR\&\fR\&, \fB\fIieee754.js(1)\fR\&\fR\&, \fB\fIheart.js(1)\fR\&\fR\&, \fB\fInitro.js(1)\fR\&\fR\&, \fB\fImq.js(1)\fR\&\fR\&, \fB\fIn2o.js(1)\fR\&\fR\&