<!DOCTYPE html><html><head><meta charset="utf-8" /><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="description" content="" /><meta name="author" content="Maxim Sokhatsky" /><title>N2O</title><link rel="stylesheet" href="https://synrc.space/synrc.css" /></head><body><nav>
    <a href="https://n2o.dev">DEV</a>
    <a href="https://ws.n2o.space" style="background:#ededed;">N2O</a>
    <a href="man/ua/index.html">UA</a>
    <a href="index.html" style="background:#ededed;">EN</a>
</nav><header>
    <a href="https://github.com/synrc/n2o"><img src="https://synrc.space/images/Synrc Neo.svg?v=1" /></a>
    <h1>N2O</h1>
</header><aside>
    <article>
        <section>
            <h3>SYNOPSIS</h3>
            <div>N2O is an embeddable message protocol loop library for
                 WebSocket, MQTT and TCP servers. It provides basic
                 features, such as: process management; virtual nodes ring for
                 request processing; session, encoding, mq and cache services.
            </div>
        </section>

        <section>
            <a name="plugin"></a><h3>USAGE</h3>
            <div>You can get rebar dependency and compile it:</div>
        <figure>
        <code>
 $ mad get n2o
 $ cd deps/n2o
 $ mad dep com pla rep
        </code>
        </figure>
            <div>
                MAY 2019 © <a href="https://github.com/5HT">5HT</a> <a href="https://5ht.co/license.htm">ISC</a><br />
                VER 6.7 6.6 6.5
            </div>
        </section>
    </article>
</aside><main>
    <section>
        <a name="endpoint"></a><h3>Endpoints</h3>
        <p>
            Here is a list of types of endpoints which are supported by EMQ and accessible to N2O apps:
            WebSockets, MQTT, MQTT-SN, TCP, UDP, CoAP.
            Normal use of N2O as a Web Framework or a Web Application Server is through WebSockets,
            but for IoT and MQTT applications it could be served through UDP or SCTP protocols,
            providing application level message delivery consistency.
            By using MQTT as a transport we extend the supported set of endpoint protocols.
        </p>
    </section>
    <section>

        <a name="mqtt"></a><h3>MQTT</h3>
        <p> <a href="http://emqx.io">EMQ</a> is an open-source MQTT broker implemented by Feng Lee.
            N2O is EMQ compatible plugin that acts as predefined MQTT clients that form
            a ring of virtual nodes, process all the protocol requests,
            and answer to client topics according to classical RPC over MQ schema.
            This list of modules forms a core of N2O that is common for
            both MQTT and WebSocket versions:
        </p>
        <div>
        <ul><li><b><a href="man/n2o.htm">n2o</a></b> — N2O Application<div class="desk">: MQTT and WS — 10KB</div></li><li><b><a href="man/n2o_pi.htm">n2o_pi</a></b> — N2O Processes<div class="desk"> — 4KB</div></li><li><b><a href="man/n2o_proto.htm">n2o_proto</a></b> — N2O Loop<div class="desk">: — 1KB</div></li><li><b><a href="man/n2o_ring.htm">n2o_ring</a></b> — N2O Ring<div class="desk">: Hash Ring — 1KB</div></li></ul>
        </div>
        <figure>
        <code>
 $ mad app mqtt review
 $ cd review
 $ mad dep com pla rep
 $ open http://127.0.0.1:8000
        </code></figure>
        <div>
        <p>The list of MQTT specific modules:</p>
        <ul><li><b><a href="man/n2o_auth.htm">n2o_auth</a></b> — N2O MQTT Authentication<div class="desk">: MQTT auth module — 1KB</div></li><li><b><a href="man/n2o_mqtt.htm">n2o_mqtt</a></b> — MQTT DHT Virtual Node</li></ul>
        </div>
    </section>


    <section>
        <a name="ws"></a><h3>WebSocket</h3>
        <p> <a href="https://ninenines.eu">COWBOY</a> is small, fast, and modern HTTP server implemented by Loïc Hoguin.
            In this version, N2O loop is integrated as WebSocket <b>cowboy</b>
            handler that routes all incoming messages to N2O.
            The list of WebSocket specific modules:</p>
        <ul><li><b><a href="man/n2o_stream.htm">n2o_stream</a></b> — COWBOY and XHR bridge</li><li><b><a href="man/n2o_cowboy.htm">n2o_cowboy</a></b> — COWBOY API</li><li><b><a href="man/n2o_ws.htm">n2o_ws</a></b> — WebSocket DHT Virtual Node</li></ul>
        <figure>
        <code>
 $ mad app web sample
 $ cd sample
 $ mad dep com pla rep
 $ open https://127.0.0.1:8001/app/index.htm
        </code></figure>
    </section>


    <section>
        <a name="protocols"></a><h3>Protocols</h3>
        <ul><li><b><a href="man/n2o_heart.htm">n2o_heart</a></b> — PING protocol</li><li><b><a href="man/n2o_ftp.htm">n2o_ftp</a></b> — N2O File Protocol<div class="desk">: FTP — 4KB</div></li><li><b><a href="man/n2o_nitro.htm">n2o_nitro</a></b> — N2O Nitrogen Web Framework Protocol<div class="desk">:  — 3KB</div></li></ul>
    </section>

    <section>
        <a name="services"></a><h3>Services</h3>
        <ul><li><b><a href="man/n2o_session.htm">n2o_session</a></b> — ETS sessions backend</li><li><b><a href="man/n2o_secret.htm">n2o_secret</a></b> — AES/CBC-128 encoder/decoder</li><li><b><a href="man/n2o_gproc.htm">n2o_gproc</a></b> — GPROC MQ backend</li><li><b><a href="man/n2o_syn.htm">n2o_syn</a></b> — SYN MQ backend</li></ul>
    </section>


    <section>
        <a name="js"></a><h3>JavaScript</h3>

        <ul><li><b><a href="man/utf8.js.htm">utf8.js</a></b> — UTF-8 encoder/decoder</li><li><b><a href="man/ieee754.js.htm">ieee754.js</a></b> — IEEE-754 encoder/decoder</li><li><b><a href="man/bert.js.htm">bert.js</a></b> — BERT encoder/decoder</li><li><b><a href="man/n2o.js.htm">n2o.js</a></b> — N2O protocol looper</li><li><b><a href="man/heart.js.htm">heart.js</a></b> — HEART protocol</li><li><b><a href="man/nitro.js.htm">nitro.js</a></b> — NITRO protocol</li><li><b><a href="man/ftp.js.htm">ftp.js</a></b> — FTP protocol</li><li><b><a href="man/mq.js.htm">mq.js</a></b> — MQTT client</li></ul>

    </section>

    <section>
        <a name="js"></a><h3>SPEC</h3>
         <figure><figcaption>N2O:</figcaption><code>
 -type n2o()       :: #bert{} | #json{} | #binary{} | #default{}.
 -type cx()        :: #cx{}.
 -type formatter() :: binary | json | bert | text | default | atom().
 -type response()  :: { formatter(), binary() }.

 -record(ok,      { data     :: term() }).
 -record(error    { data     :: term() }.
 -record(reply,   { msg      :: n2o(), req :: term(), ctx :: cx() } ).
 -record(unknown, { msg      :: n2o(), req :: term(), ctx :: cx() } ).

 -spec start(#pi{}) -> {pid(),term()} | #error{}.
 -spec stop(term(),atom()) -> #pi{} | #error{}.
 -spec proc(atom(),#pi{}) -> term().
 -spec info(term(),term(),#cx{}) -> #reply{} | #unknown{}.

 -record(pi, { name     :: term(),
               table    :: atom(),
               sup      :: atom(),
               module   :: atom(),
               state    :: term()  }).

 -record(cx, { handlers  = [] :: list({atom(),atom()}),
               actions   = [] :: list(tuple()),
               req       = [] :: [] | term(),
               module    = [] :: [] | atom(),
               lang      = [] :: [] | atom(),
               path      = [] :: [] | binary(),
               session   = [] :: [] | binary(),
               formatter = bert :: bert | json | atom(),
               params    = [] :: [] | list(tuple()),
               node      = [] :: [] | atom(),
               client_pid= [] :: [] | term(),
               state     = [] :: [] | term(),
               from      = [] :: [] | binary(),
               vsn       = [] :: [] | binary() }).

 -type memtable()  :: atom().
 -spec encode(tuple()) -> binary().
 -spec decode(binary()) -> tuple().
 -spec session(term(),term()) -> term().
 -spec session(term()) -> term().
 -spec cache(memtable(),term(),term()) -> term().
 -spec cache(memtable(),term()) -> term().
         </code></figure>
         <br /><br />
    </section>
</main><footer>
    Made with <span class="heart">❤</span> to Erlang
</footer></body></html>